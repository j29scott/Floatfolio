:- module(flatzinc).
:- export fzn_obj_lookup / 2.
:- export fzn_write / 4.
:- export fzn_write / 2.
:- export fzn_var_lookup / 3.
:- export zn_options / 2.
:- export fzn_last / 1.
:- export fzn_output / 1.
:- export fzn_search / 1.
:- export fzn_load_stream / 2.
:- export fzn_init / 2.
:- export fzn_run / 2.
:- export fzn_run_stream / 2.
:- export fzn_run / 1.
:- export fzn_error / 2.
:- export struct(zn_options(solver, parser, var_names, solutions, fzn_tmp, setup_prio)).
:- export struct(zn_var(id, ann, type, group, eclvar, num)).
:- comment(date, "$Date: 2008/06/20 17:21:23 $").
:- comment(summary, "Interpreter for FlatZinc").
:- comment(author, "Joachim Schimpf, supported by Cisco Systems and NICTA Victoria").
:- comment(copyright, "Cisco Systems Inc, licensed under CMPL").
:- comment(see_also, [library(flatzinc_parser), library(fzn_ic), library(fzn_fd), library(fzn_eplex)]).
:- comment(status, prototype).
:- comment(desc, html("\n<H3>\nOverview\n</H3>\n<P>\nThe core of this module is an interpreter for FlatZinc models, based\non 'Specification of FlatZinc' (Nov 7 2007).  It uses\nlib(flatzinc_parser) to read a FlatZinc model one item at a time, and\nimmediately interprets it.  The mapping from FlatZinc built-in\noperations to actual ECLiPSe solver operations is in separate modules\ncalled fzn_ic, fzn_fd, fzn_eplex, etc.\n</P>\n\n<H3>\nRunning FlatZinc Models\n</H3>\n<P>\nIf you have a file containing a FlatZinc model, it can be loaded and\nexecuted from ECLiPSE by calling\n<PRE>\n    ?- fzn_run(\"model.fzn\", fzn_ic).\n</PRE>\nwhere model.fzn is the file name and fzn_ic is the name of the chosen\nsolver mapping. It is also possible to read a model from the standard\ninput using fzn_run/1, or from an arbitrary ECLiPSe input stream using\nfzn_run_stream/2.\n</P>\nIf finer control is needed, the processing of a FlatZinc model can be\nsplit up into initialization, loading and constraint-set-up, search,\nand output.  The primitives that perform these steps are exported\nand can be invoked separately, e.g.\n<PRE>\nmy_fzn_run_stream(ModelStream, Options) :-\n\n\t% initialize the solver state\n\tfzn_init(Options, State),\n\n\t% load the model and set up the constraints\n\tfzn_load_stream(ModelStream, State),\n\n\t% perform the search\n\tfzn_search(State),\n\n\t% output solution, if found\n\tfzn_output(State).\n</PRE>\n</P>\n\n<H3>\nCreating FlatZinc Models\n</H3>\n<P>\nNote that FlatZinc is not intended to be written by humans, but\ncreated by translating models written in Zinc or MiniZinc.  A\ntranslator for MiniZinc to FlatZinc called mzn2fzn is available at\n<A HREF=\"http://nicta.com.au/research/projects/constraint_programming_platform/minizinc\">\nhttp://nicta.com.au/research/projects/constraint_programming_platform/minizinc</A>\n</P>\n<P>\nThe use of an intermediate FlatZinc file can be avoided by\npiping the result of the MiniZinc to FlatZinc converter directly\ninto the ECLiPSe-FlatZinc interpreter, e.g. via\n<PRE>\n% mzn2fzn --output-to-stdout model.mzn | eclipse -e \"flatzinc:fzn_run(fzn_ic)\"\n</PRE>\nThe file lib/fzn_ic/globals.mzn contains specialised global constraint\ndefinitinions for the use of fzn_ic.\nFor alternative ways to run MiniZinc models, see library(minizinc).\n</P>\n\n<H3>\nHow to write a new solver mapping\n</H3>\n<P>\nThe mapping from FlatZinc built-in operations to actual ECLiPSe solver\noperations is defined in separate modules called fzn_ic, fzn_eplex, etc. \nTo add a new mapping, create a new module file called fzn_xxx.ecl, and\nplace it in your library_path.\nThese modules should export predicates corresponding to the \"built-in\"\noperations defined by FlatZinc, i.e.\n<CODE>\nint_lin_le/3, float_times/3,\n</CODE>\netc.  See the FlatZinc specification for a complete list.\n</P><P>\nIn addition to those, we require the following interface predicates:\n</P><P>\nFor initialising variables:\n<CODE>\nbool_declare(-var),\nint_declare(-var),\nint_declare(-var, +list),\nint_declare(-var, +min, +max),\nfloat_declare(-var),\nfloat_declare(-var, +min, +max),\nset_declare(-var, +min, +max),\nset_declare(-var, +list)\n</CODE>\n</P><P>\nFor initialising arrays:\n<CODE>\nbool_declare_array(-array),\nint_declare_array(-array),\nint_declare_array(-array, +list),\nint_declare_array(-array, +min, +max),\nfloat_declare_array(-array),\nfloat_declare_array(-array, +min, +max),\nset_declare_array(-array, +min, +max),\nset_declare_array(-array, +list)\n</CODE>\n</P><P>\nFor invoking search:\n<CODE>\nsatisfy(+annotations),\nminimize(+objective, +annotations, -cost),\nmaximize(+objective, +annotations, -cost)\n</CODE>\n</P><P>\nFor converting constants in the Zinc model to the appropriate solver\ntype in ECLiPSe (e.g. floats to breals when using lib(ic)):\n<CODE>\nbool_fzn_to_solver(+atom, -bool),\nbool_solver_to_fzn(+bool, -atom),\nfloat_fzn_to_solver(+float, -real),\nfloat_solver_to_fzn(+real, -float),\nset_fzn_to_solver(+list, -set),\nset_solver_to_fzn(+set, -list),\nrange_fzn_to_solver(+min, +max, -set).\n</CODE>\n</P>\n<P>\n<H3>\nFurther Details\n</H3>\nBy default, the 'output' primitive suppresses all variables with\nthe var_is_introduced annotation.\n<H3>\nTODO\n</H3>\n<UL>\n<LI>interpret more variable annotations</LI>\n<LI>constraint annotations (currently ignored)</LI>\n<LI>stricter checking of the FlatZinc input?</LI>\n</UL>\n</P>\n")).
:- comment(struct(zn_options), [summary : "Options for Mini/FlatZinc solving", fields : ["solver" : "\n    \tDetermines which ECLiPSe solver(s) the FlatZinc variables and\n\tconstraints get mapped to. The name is the name of a library\n\timplementing the mapping, e.g. fzn_ic, fzn_fd or fzn_eplex.\n\tThe default is 'fzn_ic'.", "fzn_tmp" : "\n\tOne of the atoms 'file' or 'pipe', determining if intermediate\n\tFlatZinc code is piped from the generator to the interpreter,\n\tor passed through an intermediate file. Default is 'file'.", "parser" : "\n\tOne of the atoms 'strict' or 'fast', giving the choice between\n\ta stricter, but slower dedicated FlatZinc parser (in\n\tlib(flatzinc_parser)), or a faster parsing method (which\n\tdetects less errors because it uses the normal, but\n\treconfigured ECLiPSe parser).  Since FlatZinc input is\n\tnormally automatically generated, the default is to use the\n\tfaster and more permissive method 'fast'.", "setup_prio" : "\n\tThe priority under which the constraint setup will be executed\n\t(see call_priority/2 and get_priority/1). Possible values are\n\tthe ECLiPSe priorities 1 to 12, or 0 (the default) which stands\n\tfor the current priority of the calling code.  A sensible value\n\tfor this option is 2, which means that the setup code is executed\n\tunder high priority (still allowing debug/visuialisation goals).\n\tThe effect of such a setting is that no propagation occurs until\n\tall constraints are fully set up, possibly leading to time savings.", "solutions" : "\n\tThe maximum number of solutions computed (and possibly output).\n\tOnly effective if no minimization/maximization is done.\n\tOnly effective for toplevel predicates like fzn_run/mzn_run\n\tthat are deterministic and do not succeed once per solution.\n\tDefault is 1, zero means no limit.", "var_names" : "\n\tIf this option is set to 'on', the ECLiPSe variables representing\n\tZinc variables will be marked with their Zinc names, using the\n\tfacilities of lib(var_name).  This is mainly useful for debugging.\n\tThe default is 'off' to save space and time."], see_also : [fzn_run / 1, fzn_run / 2, fzn_run_stream / 2, fzn_init / 2], desc : html("<P>\n\tUsed to specify options for Mini/FlatZinc solving.\n    </P><P>\n    \tAll predicates that accept the zn_options structure also accept\n\tthe name of a solver mapping library alone. In this case, all\n\tother options take their default values.\n    </P>"), eg : "\n    ?- fzn_run(\"queens.fzn\", fzn_ic).\n    ?- fzn_run(\"queens.fzn\", zn_options{solver:fzn_ic,solutions:3}).\n    "]).
:- comment(struct(zn_var), [summary : "Descriptor for a Mini/FlatZinc variable", fields : ["id" : "(atom) Mini/FlatZinc name", "ann" : "List of variable annotations", "type" : "FlatZinc type descriptor (structure)", "group" : "simplified type descriptor (atom)", "eclvar" : "Corresponding ECLiPSe variable", "num" : "Variable number in input order"], see_also : [fzn_var_lookup / 3]]).
:- comment(fzn_init / 2, [summary : "Initialize a FlatZinc solver", amode : (fzn_init(++, -) is det), args : ["SolverOrOptions" : "Name of solver mapping module, or zn_options-structure", "FznState" : "Output: a FlatZinc state descriptor"], see_also : [fzn_load_stream / 2, fzn_search / 1, fzn_output / 1, struct(zn_options)], desc : html("<P>\n\tInitialize a FlatZinc solver and return a descriptor, ready\n\tfor loading the model.  The given solver options are taken\n\tinto account and remembered in the descriptor.\n    </P>"), eg : "\n    my_fzn_run_stream(ModelStream, Options) :-\n\tfzn_init(Options, State),\n\tfzn_load_stream(ModelStream, State),\n\tfzn_search(State),\n\tfzn_output(State).\n"]).
:- comment(fzn_last / 1, [summary : "Increments solutions count, and succeeds if last one reached", amode : (fzn_last(+) is semidet), fail_if : "Fails if not enough solutions found yet", args : ["FznState" : "a FlatZinc state descriptor"], see_also : [struct(zn_options), fzn_init / 2, fzn_search / 1], desc : html("<P>\n\tAssuming a model has previously been loaded successfully\n\tusing fzn_load_xxx or mzn_load_xxx, this primitive can be used\n\tto limit the number of solutions produced.  It increments a\n\tnonlogical counter and fails as long as the number of solutions\n\tthat were requested in the zn_options has not yet been reached.\n    </P>"), eg : "\n    my_fzn_run_stream(ModelStream, Options) :-\n\tfzn_init(Options, State),\n\tfzn_load_stream(ModelStream, State),\n\tfzn_search(State),\n\tfzn_output(State),\n\tfzn_last(State),\n\t!.\n    "]).
:- comment(fzn_load_stream / 2, [summary : "Load a FlatZinc model and set up its constraints", amode : (fzn_load_stream(+, -) is semidet), fail_if : "Fails if any constraint fails during setup", args : ["ModelStream" : "An ECLiPSe stream name or handle", "FznState" : "a FlatZinc state descriptor"], see_also : [fzn_init / 2, fzn_search / 1, fzn_output / 1, fzn_var_lookup / 3, struct(zn_options)], desc : html("<P>\n\tLoad a FlatZinc model and set up its constraints.  The options\n\tthat were used in fzn_init/2 will be taken into account.\n\tIf fzn_load_stream/2 succeeds, all constraints have been\n\tsuccessfully set up, and the search phase can begin.\n    </P><P>\n    \tThis predicate will always close ModelStream on success,\n\tfailure or abort.\n    </P>"), eg : "\n    my_fzn_run_stream(ModelStream, Options) :-\n\tfzn_init(Options, State),\n\tfzn_load_stream(ModelStream, State),\n\tfzn_search(State),\n\tfzn_output(State).\n"]).
:- comment(fzn_obj_lookup / 2, [summary : "Find ECLiPSe term representing the Mini/FlatZinc model's objective", amode : (fzn_obj_lookup(+, -) is semidet), fail_if : "Fails if the model has no objective", args : ["FznState" : "a FlatZinc state descriptor", "Obj" : "Output: ECLiPSe constant or domain variable"], see_also : [fzn_load_stream / 2, fzn_var_lookup / 3, library(minizinc)], desc : html("<P>\n\tAssuming a model has previously been loaded successfully\n\tusing fzn_load_xxx or mzn_load_xxx, this primitive returns\n\tthe ECLiPSe term that represents the model's objective.\n\tThis can be used for instance by a branch-and-bound primitive.\n    </P>")]).
:- comment(fzn_output / 1, [summary : "Perform a FlatZinc model's output actions", amode : (fzn_output(+) is det), args : ["FznState" : "a FlatZinc state descriptor"], see_also : [fzn_init / 2, fzn_load_stream / 2, fzn_search / 1], desc : html("<P>\n\tAssuming that a FlatZinc model has previously been set up\n\tand solved, this predicate will perform the output actions\n\tspecified in the model's output item.  If no output item\n\twas specified, a default output will be generated, consisting\n\tof the display of values of all model variables in input order.\n\tIn addition, statistics information will be printed to the\n\tlog_output stream.\n    </P>"), eg : "\n    my_fzn_run_stream(ModelStream, Options) :-\n\tfzn_init(Options, State),\n\tfzn_load_stream(ModelStream, State),\n\tfzn_search(State),\n\tfzn_output(State).\n"]).
:- comment(fzn_run / 1, [summary : "Run a FlatZinc model from standard input", amode : (fzn_run(+) is det), args : ["SolverOrOptions" : "Name of solver mapping module, or zn_options-structure"], see_also : [fzn_run / 2, fzn_run_stream / 2], desc : html("<P>\n\tReads a FlatZinc model from the input stream, and interprets it using\n\tthe solver mapping defined in SolverOrOptions.  At the end of\n\tsolving, resuls and timings are printed to the output stream. \n\tError messages may be printed to the error stream.  This\n\tpredicate always succeeds. It is equivalent to:\n    <PRE>\n    fzn_run(SolverOrOptions) :-\n\tfzn_run_stream(input, SolverOrOptions).\n    </PRE>\n    </P>"), eg : "\n    % generate_model | eclipse -e \"flatzinc:fzn_run(fzn_ic)\"\n"]).
:- comment(fzn_run / 2, [summary : "Run a FlatZinc model from a given file", amode : (fzn_run(+, ++) is det), args : ["File" : "File name (extension defaults to .fzn)", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure"], see_also : [fzn_run / 1, fzn_run_stream / 2], desc : html("<P>\n\tReads a FlatZinc model from a file, and interprets it using\n\tthe solver mapping defined in SolverOrOptions.  At the end of\n\tsolving, resuls and timings are printed to the output stream. \n\tError messages may be printed to the error stream.  This\n\tpredicate always succeeds.\n    </P>"), eg : "\n    ?- fzn_run(\"mymodel.fzn\", fzn_ic).\n\tFound a solution with cost 10\n\tFound no solution with cost 7.0 .. 9.0\n\tend = 10\n\tb1 = 1\n\tb2 = 0\n\tb3 = 1\n\tb4 = 0\n\tObjective value = 10\n\tTotal time 0.031s cpu (0.016 setup + 0.000 search)\n"]).
:- comment(fzn_run_stream / 2, [summary : "Run a FlatZinc model from a given open input stream", amode : (fzn_run_stream(+, ++) is det), args : ["Stream" : "ECLiPSe stream name or handle", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure"], see_also : [fzn_run / 1, fzn_run / 2], desc : html("<P>\n\tReads a FlatZinc model from a stream, and interprets it using\n\tthe solver mapping defined in SolverOrOptions.  At the end of\n\tsolving, resuls and timings are printed to the output stream. \n\tError messages may be printed to the error stream.  This\n\tpredicate always succeeds and closes the stream.\n    </P>"), eg : "\n    ?- open(\"mymodel.fzn\",read,S), fzn_run_stream(S, fzn_ic).\n\tFound a solution with cost 10\n\tFound no solution with cost 7.0 .. 9.0\n\tend = 10\n\tb1 = 1\n\tb2 = 0\n\tb3 = 1\n\tb4 = 0\n\tObjective value = 10\n\tTotal time 0.031s cpu (0.016 setup + 0.000 search)\n"]).
:- comment(fzn_search / 1, [summary : "Run the search part of a FlatZinc model", amode : (fzn_search(+) is nondet), fail_if : "Fails if no (further) solution is found", args : ["FznState" : "FlatZinc state descriptor"], see_also : [fzn_init / 2, fzn_load_stream / 2, fzn_output / 1], desc : html("<P>\n\tPerform the search part of a FlatZinc model, as specified in\n\tthe model's solve-item.  The model must previously have been\n\tloaded successfully using fzn_load_xxx or mzn_load_xxx.\n\tIf the solve item was 'satisfy', multiple solutions may be\n\treturned on backtracking.\n    </P>"), eg : "\n    my_fzn_run_stream(ModelStream, Options) :-\n\tfzn_init(Options, State),\n\tfzn_load_stream(ModelStream, State),\n\tfzn_search(State),\n\tfzn_output(State).\n"]).
:- comment(fzn_var_lookup / 3, [summary : "Find ECLiPSe term corresponding to Mini/FlatZinc identifier", amode : (fzn_var_lookup(+, +, -) is semidet), fail_if : "Fails if there is no such identifier", args : ["FznState" : "a FlatZinc state descriptor", "Id" : "Mini/FlatZinc identifier (atom)", "Value" : "Output: ECLiPSe constant, array or domain variable"], see_also : [fzn_load_stream / 2, fzn_obj_lookup / 2, library(minizinc)], desc : html("<P>\n\tAssuming a model has previously been loaded successfully\n\tusing fzn_load_xxx or mzn_load_xxx, this primitive provides\n\tthe mapping from Mini/FlatZinc identifier to the ECLiPSe\n\tterm that it is mapped to.\n    </P>")]).
