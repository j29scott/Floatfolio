:- module(minizinc).
:- export mzn2fzn / 4.
:- export mzn_load / 5.
:- export mzn_load_string / 5.
:- export mzn_run_string / 2.
:- export mzn_run / 3.
:- export mzn_run / 2.
:- reexport struct(_17567) from flatzinc.
:- export macro((of) / 2, minizinc : tr_of / 2, []).
:- comment(date, "$Date: 2008/06/20 17:21:25 $").
:- comment(summary, "Utilities for using MiniZinc with ECLiPSe").
:- comment(author, "Joachim Schimpf, supported by Cisco Systems and NICTA Victoria").
:- comment(copyright, "Cisco Systems Inc, licensed under CMPL").
:- comment(see_also, [library(flatzinc), library(fzn_ic), library(fzn_fd), library(fzn_eplex)]).
:- comment(status, prototype).
:- comment(desc, html("\n<H3>\nOverview\n</H3>\n<P>\nThis module allows to run MiniZinc models with ECLiPSe.\nMiniZinc models can be either read from a file or stream,\nor they can be embedded as strings into ECLiPSe code.\nThe implementation relies on an external MiniZinc-to-FlatZinc converter,\ne.g. mzn2fzn, and on the FlatZinc interpreter lib(flatzinc).\nMappings to different ECLiPSe solvers are possible via the solver\nmapping libraries fzn_ic, fzn_fd, fzn_eplex, etc.\n</P>\n\n<H3>\nRunning MiniZinc Models without using this Library\n</H3>\n<P>\nYou can run a MiniZinc model by first converting it to FlatZinc yourself,\nand then using the lib(flatzinc) library. This can be done either via\nan intermediate .fzn file, or by piping the resulting FlatZinc model\ninto the ECLiPSe-FlatZinc interpreter using e.g.\n<PRE>\n% mzn2fzn --output-to-stdout model.mzn | eclipse -e \"flatzinc:fzn_run(fzn_ic)\"\n</PRE>\nThis should work as long as the mzn2fzn command is in your PATH.\nNote that mzn2fzn is currently not included with ECLiPSe but comes\nwith the Melbourne MiniZinc distribution.  You must also make sure that\nthe specialised globals.mzn file is used, by including e.g. lib/fzn_ic\nin mzn2fzn's search path.  For more details see lib(flatzinc).\n</P>\n\n<H3>\nRunning MiniZinc Models using this Library\n</H3>\n<P>\nThis library allows you to do everything from within ECLiPSe and let ECLiPSe\ninvoke the MiniZinc to FlatZinc translator (mzn2fzn) internally with the\ncorrect arguments.  The model can be contained in a file:\n<PRE>\n?- mzn_run(\"model.mzn\", fzn_ic).\n</PRE>\nor, if a data instance file is used\n<PRE>\n?- mzn_run(\"model.mzn\", \"instance.mzn\", fzn_ic).\n</PRE>\nSince MiniZinc models are typically small, they can also be embedded as\na string into ECLiPSe code. For example:\n<PRE>\n    queens8 :-\n\tmzn_run_string(\"\n\t\tint: n = 8;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \", fzn_ic).\n</PRE>\nNote that, because of the rules for escaping characters within\nECLiPSe strings, the backslashes had to be doubled!\n</P>\n\n<H3>\nInstallation\n</H3>\n<P>\nThis version is intended to to work with Minizinc 0.8 or later!\n<P>\nIn order to be found by lib(minizinc), the Melbourne Minizinc-to-Flatzinc\nconverter mzn2fzn must be installed in a directory called <CODE>minizinc-&lt;version&gt;</CODE>\nin one of the following locations (where we write &lt;ECLIPSEDIR&gt; for\nthe ECLiPSe installation directory, and &lt;ECLIPSEARCH&gt; for\nthe name for the machine architecture, e.g. i386_nt for Windows, i386_linux\nfor Linux):\n<OL>\n<LI>Directory specified by <CODE>$ECLIPSEMZN</CODE> environment variable</LI>\n<LI>The user's home directory, as indicated by $HOME or $HOMEPATH</LI>\n<LI><CODE>&lt;location of lib(minizinc)&gt;/&lt;ECLIPSEARCH&gt;</CODE></LI>\n<LI><CODE>&lt;ECLIPSEDIR&gt;/lib_public/&lt;ECLIPSEARCH&gt;</CODE></LI>\n<LI><CODE>&lt;ECLIPSEDIR&gt;/lib/&lt;ECLIPSEARCH&gt;</CODE></LI>\n<LI><CODE>&lt;ECLIPSEDIR&gt;</CODE></LI>\n<LI>Parent of <CODE>&lt;ECLIPSEDIR&gt;</CODE> (e.g. \"C:/Program Files\" on Windows)</LI>\n</OL>\n<P>\nFor MiniZinc on Windows, it may be necessary to copy a cygwin1.dll into\nthe MiniZinc distribution's bin/private folder.\n\n\n<H3>\nCombining a MiniZinc model with Search or I/O in ECLiPSe\n</H3>\n<P>\nThere are several reasons why one might want to embed a MiniZinc model\ninto an ECLiPSe program:\n<UL>\n<LI>Passing parameters from the ECLiPSe program to the MiniZinc model</LI>\n<LI>Getting the model solutions back into ECLiPSe</LI>\n<LI>Programming custom search in ECLiPSe</LI>\n<LI>Doing custom output beyond what the Zinc output primitive can do</LI>\n</UL>\n</P><P>\nTo pass a parameter into a MiniZinc model, a generic MiniZinc model must\nbe provided, together with a parameter map.\nThis map is an ECLiPSe list that corresponds to a MiniZinc (actually\nFlatZinc) instance file:\n<PRE>\nqueens(N) :-\n\tmzn_run_string(\"\n\t\tint: n;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \",\n\t    [n=N],\t% parameter map: ZincId=EclipseValue\n\t    fzn_ic).\n</PRE>\nAlternatively, the generic model can be kept separately in a MiniZinc file:\n<PRE>\nqueens(N) :-\n\tmzn_run(\"n_queens.mzn\", [n=N], fzn_ic).\n</PRE>\n<P>\nWith the above exmples, search and output are still completely specified\nin MiniZinc.\n</P><P>\nTo add your own search routine and/or output, use mzn_load_string/5 or\nmzn_load/5. This has the effect of only loading the MiniZinc model\n(i.e. setting up the constraints), but then returning to ECLiPSe without\nexecuting any MiniZinc solve or output primitives.  The rest of the work\ncan then be done in ECLiPSe:\n</P>\n<PRE>\nqueens(N, Q) :-\n\tmzn_load(\"n_queens.mzn\", fzn_ic, [n=N], [q=Q], FznState),\n\tlabeling(Q),\n\tfzn_output(FznState).\n</PRE>\nThe [q=Q] mapping gives access to the ECLiPSe array Q corresponding to\nthe MiniZinc array q. This is a normal ECLiPSe array of lib(ic) domain\nvariables, and can be used for doing search, or outputting the results.\nIn the example however, we have fallen back onto the FlatZinc output\nroutine to display the results after search has finished.\n</P><P>\nNote that even if you do your own search in ECLiPSe, your MiniZinc model\nmust contain a solve item to be syntactically correct (and to specify\nthe objective, if any).\n</P>\n\n<H3>\nOptions\n</H3>\nInstead of just the name of the solver mapping (<CODE>fzn_ic</CODE> in\nour examples), a <CODE>zn_options{}</CODE> structure can be given to\ncustomize the behaviour further, e.g.\n<PRE>\n\tmzn_run(File, zn_options{solver:fzn_eplex,var_names:on}.\n</PRE>\n<DL>\n<DT>solver (default: fzn_ic)</DT><DD>\n    Determines which ECLiPSe solvers are used.\n</DD>\n<DT>solutions (default: 1)</DT><DD>\n    The maximum number of solutions computed is using builtin search.\n    (0 = all)\n</DD>\n<DT>parser (default: fast)</DT><DD>\n    Whether to use a 'strict' or 'fast' parser for FlatZinc input.\n</DD>\n<DT>var_names (default: off)</DT><DD>\n    Use lib(var_name) to label ECLiPSe variables with their Zinc names.\n    This is useful for debugging.\n</DD>\n<DT>fzn_tmp (default: file)</DT><DD>\n    Use a 'pipe' or intermediate 'file' for FlatZinc.\n</DD>\n</DL>\n\n<H3>\nMapping between MiniZinc/FlatZinc Data and ECLiPSe Data\n</H3>\n<P>\nWhen using ECLiPSe with a Mini/FlatZinc model, one needs to be aware of\nthe mapping from MiniZinc to FlatZinc (e.g. flattening of arrays),\nand the representation of FlatZinc data in ECLiPSe.\n</P><P>\nNote that the ECLiPSe-side representation depends in part on the chosen\nsolver mapping. The following table shows the mapping used with fzn_ic\n(which employs the lib(ic) and lib(ic_sets) solver libraries):\n<PRE>\n\tFlatZinc Type/Syntax\t\tECLiPSe Type/Syntax\n\t-----------------------------------------------------------\n\tstring\t\t\t\tstring\n\te.g.\t\"abc\"\t\t\t\"abc\"\n\n\tbool (false/true)\t\tinteger (0/1)\n\te.g.\tfalse\t\t\t0\n\n\tint\t\t\t\tinteger\n\te.g.\t33\t\t\t33\n\n\tfloat\t\t\t\tfloat or breal\n\te.g.\t3.4\t\t\t3.399__3.401\n\n\tset of int\t\t\tordered list of integer\n\te.g.\t{1,5,4}\t\t\t[1,4,5]\n\t\t1..3\t\t\t[1,2,3]\n\n\tarray[1..N] of T\t\tstructure with functor []/N\n\te.g.\t[23,54,0]\t\t[](23,54,0)\n\n\tvar bool\t\t\tlib(ic) integer variable\n\n\tvar int\t\t\t\tlib(ic) integer variable\n\n\tvar float\t\t\tlib(ic) continuous variable\n\n\tvar set of int\t\t\tlib(ic_sets) set variable\n</PRE>\n</P>\n")).
:- comment(mzn2fzn / 4, [summary : "Convert a MiniZinc model into a FlatZinc model", amode : (mzn2fzn(+, +, ++, -) is det), args : ["ModelFile" : "File name (extension defaults to .mzn)", "InstFileOrParMap" : "Instance file name (extension defaults to .mzn), or list of Id=Term correspondences", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure", "FznFile" : "Output: name of generated FlatZinc file"], see_also : [mzn_run / 3, flatzinc : fzn_run / 2, struct(zn_options)], desc : html("<P>\n\tConverts a MiniZinc model (given a model file and an instance\n\tfile or parameter map) into a FlatZinc model, by invoking the\n\texternal mzn2fzn converter with the appropriate arguments.\n\tThe name of the output file is the same as the input file, with\n\tthe extension changed to .fzn.  The options should specify the\n\tsolver that is intended to be used on the FlatZinc model (so that\n\tthe correct version of globals.mzn is used), and the fzn_tmp\n\toption should be set to 'file' (the default).\n    </P>"), eg : "\n    ?- mzn2fzn(mymodel, [], zn_options{solver:fzn_ic,fzn_tmp:file}, FznFile).\n    FznFile = \"mymodel.fzn\"\n    Yes (0.00s cpu)\n"]).
:- comment(mzn_load / 5, [summary : "Load a MiniZinc model from a file", amode : (mzn_load(++, ++, ++, +, -) is semidet), args : ["ModelFile" : "File name (extension defaults to .mzn)", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure", "ParMap" : "List of FznId=ECLiPSeGroundTerm correspondences", "VarMap" : "List of FznId=ECLiPSeVarTerm correspondences", "FznState" : "FlatZinc state descriptor"], fail_if : "Fails if the constraint setup fails", see_also : [mzn_run / 2, mzn_run / 3, mzn_load_string / 5, struct(zn_options)], desc : html("<P>\n\tLoads a MiniZinc from ModelFile.  The problem is set up using\n\ta mapping to a concrete ECLiPSe solver, as specified in the\n\tSolverOrOptions argument.  Neither search nor output are done.\n    </P><P>\n\tTo pass parameters into the model, a ParMap can be given, consisting\n\tof a list of FznId=ECLiPSeGroundTerm correspondences.  Here, FznId\n\tis an atom (the FlatZinc parameter identifier within the model),\n\tand ECLiPSeGroundTerm is the corresponding ECLiPSe constant.\n    </P><P>\n    \tTo access the ECLiPSe variables corresponding to the model's\n\tvariables, VarMap can be given, consisting of a list of\n\tFznId=ECLiPSeTerm correspondences.  Here, FznId is an atom\n\t(the FlatZinc variable identifier within the model), and\n\tECLiPSeTerm is the corresponding ECLiPSe constant, variable\n\tor array.\n    </P><P>\n    \tThe mzn_load/5 predicate returns a FlatZinc solver\n\tstate which can be used to lookup further information about\n\tthe model (fzn_var_lookup/3, fzn_obj_lookup/2), to perform\n\tthe standard search (fzn_search/1), or to perform the model's\n\toutput actions (fzn_output/1).\n    </P>"), eg : "\n    ?- mzn_load(\"queens\", fzn_ic, [n=8], [q=Q], FznState).\n\n    Q = [](_2492{1..8}, _2512{1..8}, _2532{1..8}, _2552{1..8}, ...]\n    FznState = state(...)\n    There are 84 delayed goals.\n    Yes (0.02s cpu)\n\n\n    ?- mzn_load(\"queens\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q).\n\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n\n\n    ?- mzn_load(\"queens\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q),\n       fzn_output(FznState).\n\n    % output from fzn_output:\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.030s cpu (0.020 setup)\n\n    % output from ECLiPSe toplevel:\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n</PRE>\n"]).
:- comment(mzn_load_string / 5, [summary : "Load a MiniZinc model given as a string or list", amode : (mzn_load_string(++, ++, ++, +, -) is semidet), args : ["MznModel" : "String, Atom or List of constants", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure", "ParMap" : "List of FznId=ECLiPSeGroundTerm correspondences", "VarMap" : "List of FznId=ECLiPSeVarTerm correspondences", "FznState" : "FlatZinc state descriptor"], fail_if : "Fails if the constraint setup fails", see_also : [mzn_run / 2, mzn_run / 3, mzn_run_string / 2, struct(zn_options)], desc : html("<P>\n\tLoads the MiniZinc model MznModel, given in the simplest form\n\tas a string in MiniZinc syntax.  The problem is set up using\n\ta mapping to a concrete ECLiPSe solver, as specified in the\n\tSolverOrOptions argument.  Neither search nor output are done.\n    </P><P>\n\tNote that, because of the rules for escaping characters within\n\tECLiPSe strings, any backslashes in the MiniZinc source have\n\tto be doubled, and double quotes must be escaped with a backslash!\n    </P><P>\n\tTo pass parameters into the model, a ParMap can be given, consisting\n\tof a list of FznId=ECLiPSeGroundTerm correspondences.  Here, FznId\n\tis an atom (the FlatZinc parameter identifier within the model),\n\tand ECLiPSeGroundTerm is the corresponding ECLiPSe constant.\n    </P><P>\n    \tTo access the ECLiPSe variables corresponding to the model's\n\tvariables, VarMap can be given, consisting of a list of\n\tFznId=ECLiPSeTerm correspondences.  Here, FznId is an atom\n\t(the FlatZinc variable identifier within the model), and\n\tECLiPSeTerm is the corresponding ECLiPSe constant, variable\n\tor array.\n    </P><P>\n    \tThe mzn_load_string/5 predicate returns a FlatZinc solver\n\tstate which can be used to lookup further information about\n\tthe model (fzn_var_lookup/3, fzn_obj_lookup/2), to perform\n\tthe standard search (fzn_search/1), or to perform the model's\n\toutput actions (fzn_output/1).\n    </P>"), eg : "\n    ?- mzn_load_string(\"\n\t\tint: n;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \",\n\t    fzn_ic,\n\t    [n=8],\n\t    [q=Q],\n\t    FznState).\n\n    Q = [](_2492{1..8}, _2512{1..8}, _2532{1..8}, _2552{1..8}, ...]\n    FznState = state(...)\n    There are 84 delayed goals.\n    Yes (0.02s cpu)\n\n\n    ?- mzn_load_string(\"...\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q).\n\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n\n\n    ?- mzn_load_string(\"...\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q),\n       fzn_output(FznState).\n\n    % output from fzn_output:\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.030s cpu (0.020 setup)\n\n    % output from ECLiPSe toplevel:\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n</PRE>\n"]).
:- comment(mzn_run / 2, [summary : "Run a MiniZinc model from a given file", amode : (mzn_run(+, ++) is det), args : ["File" : "File name (extension defaults to .mzn)", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure"], see_also : [fzn_run / 2, mzn_run / 3, mzn_run_string / 2, struct(zn_options)], desc : html("<P>\n\tReads a MiniZinc model from a file, and interprets it using\n\tthe solver mapping defined in SolverOrOptions.  At the end of\n\tsolving, resuls and timings are printed to the output stream. \n\tError messages may be printed to the error stream.  This\n\tpredicate always succeeds.\n    </P>"), eg : "\n    ?- mzn_run(\"mymodel.mzn\", fzn_ic).\n    Found a solution with cost 10\n    Found no solution with cost 7.0 .. 9.0\n    end = 10\n    b1 = 1\n    b2 = 0\n    b3 = 1\n    b4 = 0\n    Objective value = 10\n    Total time 0.031s cpu (0.016 setup + 0.000 search)\n\n    ?- mzn_run(queens8, zn_options{solver:fzn_ic,solutions:3}).\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.016s cpu (0.016 setup + 0.000 search)\n    q = [1,6,8,3,7,4,2,5]\n    Total time 0.016s cpu (0.016 setup + 0.000 search)\n    q = [1,7,4,6,8,2,5,3]\n    Total time 0.016s cpu (0.016 setup + 0.000 search)\n"]).
:- comment(mzn_run / 3, [summary : "Run a MiniZinc model from a given model and instance file", amode : (mzn_run(+, +, ++) is det), args : ["ModelFile" : "File name (extension defaults to .mzn)", "InstFileOrParMap" : "Instance file name (extension defaults to .mzn), or list of Id=Term correspondences", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure"], see_also : [mzn_run / 2, mzn_run_string / 2, struct(zn_options)], desc : html("<P>\n\tReads a MiniZinc model (given a model file and an instance\n\tfile) and interprets it using the solver mapping defined in\n\tSolverOrOptions.  At the end of solving, resuls and timings\n\tare printed to the output stream.  Error messages may be\n\tprinted to the error stream.  This predicate always succeeds.\n    </P>"), eg : "\n    ?- mzn_run(\"mymodel.mzn\", \"myinstance.mzn\", fzn_ic).\n    Found a solution with cost 10\n    Found no solution with cost 7.0 .. 9.0\n    end = 10\n    b1 = 1\n    b2 = 0\n    b3 = 1\n    b4 = 0\n    Objective value = 10\n    Total time 0.031s cpu (0.016 setup + 0.000 search)\n\n    ?- mzn_run(\"queens.mzn\", [n=8], fzn_ic).\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.015s cpu (0.000 setup + 0.000 search)\n"]).
:- comment(mzn_run_string / 2, [summary : "Run a MiniZinc model given as a string or list", amode : (mzn_run_string(++, ++) is det), args : ["MznModel" : "String, Atom or List of constants", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure"], see_also : [mzn_run / 2, mzn_run / 3, struct(zn_options)], desc : html("<P>\n\tSolves the MiniZinc model MznModel, given in the simplest form\n\tas a string in MiniZInc syntax.  The problem is solved using\n\ta mapping to a concrete ECLiPSe solver, as specified in the\n\tSolverOrOptions argument.  Search and output are done according\n\tto the model's solve and output items.\n    </P><P>\n\tNote that, because of the rules for escaping characters within\n\tECLiPSe strings, any backslashes in the MiniZinc source have\n\tto be doubled, and double quotes must be escaped with a backslash!\n    </P><P>\n\tObviously, one would like to pass parameters into a model.  The\n\tmodel can therefore  be given as a list of strings in MiniZinc\n\tsyntax, interleaved with ECLiPSe ground terms that serve as \n\tparameter instantiations.  The actual MiniZinc model then\n\tconsists of the concatenation of all these parts.\n    </P>"), eg : "\n    ?- mzn_run_string(\"\n\t\tint: n = 8;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \", fzn_ic).\n\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.020s cpu (0.020 setup+ 0.000 search)\n    Yes (0.02s cpu, solution 1, maybe more)\n\n\n    ?- N=8, mzn_run_string([\"\n\t\tint: n = \",\n\t    N, \";\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \"], fzn_ic).\n\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.020s cpu (0.020 setup+ 0.000 search)\n    N = 8\n    Yes (0.02s cpu, solution 1, maybe more)\n</PRE>\n"]).
