#!/usr/bin/env python3
from src.libsvm.python.svmutil import *
import random
import json
import glob
import sys
import pdb
import pylab as plt

SolverLabels = {
    'z3': 0.0,
    'mathsat': 1.0,
    'cvc4':2.0,
    'colibri':3.0,
    'xsat':4.0
}
LabelsSolver = {
    0.0:'z3',
    1.0:'mathsat',
    2.0:'cvc4',
    3.0:'colibri',
    4.0:'xsat'
}


QF_FP_FUNCS = {
    'fp.abs' 			 : 0,
    'fp.neg' 			 : 1,
    'fp.add' 			 : 2,
    'fp.sub' 			 : 3,
    'fp.mul' 			 : 4,
    'fp.div'			 : 5,
    'fp.fma' 			 : 6,
    'fp.rem'			 : 7,
    'fp.sqrt'			 : 8,
    'fp.roundToIntegral' : 9,
    'fp.min'			 : 10,
    'fp.max'			 : 11,
    'fp.leq'			 : 12,
    'fp.lt'	             : 13,
    'fp.geq'			 : 14,
    'fp.gt'	             : 15,
    'fp.eq'	             : 16,
    'fp.isNormal'		 : 17,
    'fp.isSubnormal'	 : 18,
    'fp.isZero'			 : 19,
    'fp.isInfinite'		 : 20,
    'fp.isNaN'			 : 21,
    'fp.isNegative'		 : 22,
    'fp.isPositive'		 : 23,
}


class input:
    def __init__(self,as_str):
        self.features = []
        for i in range(len(QF_FP_FUNCS)):
            self.features.append(0.0)
        for line in as_str:
            if line.find(";  time    =") != -1:
                line = line[12:]
                line=line.replace("'", '"')
                self.times = json.loads(line)
            if line.find(";") != -1:
                continue
            for f in QF_FP_FUNCS:
                self.features[QF_FP_FUNCS[f]] += line.count(f)
        self.best_solver = "NA"
        best_time = float('inf')
        for solver in self.times:
            if self.times[solver] < best_time:
                self.best_solver = solver
                best_time = self.times[solver]






def parse_data(files):
    inputs = []

    tot = n = 10000
    for f in files:
        file = open(f)
        inputs.append(input(file.readlines()))
        n -= 1
        if n == 0:
            break

    ##normalize
    for feat in range(len(inputs[0].features)):
        mean = 0.0
        dev = 0.0
        for i in range(len(inputs)):
            mean += inputs[i].features[feat]
        mean /= len(inputs)
        for i in range(len(inputs)):
            dev += (inputs[i].features[feat] - mean) * (inputs[i].features[feat] - mean)
        dev /= len(inputs)
        dev = dev ** 0.5

        if dev != 0.0:
            for i in range(len(inputs)):
                inputs[i].features[feat] = (inputs[i].features[feat] - mean) / dev


    split = 0.5

    train_inputs = inputs[:round(split * len(inputs)) ]
    test_inputs  = inputs[round(split*len(inputs))+1:]


    train_features = []
    train_labels = []
    for inp in train_inputs:
        train_features.append(inp.features)
        train_labels.append(SolverLabels[inp.best_solver])
    pdb.set_trace()
    model = svm_train(train_labels,train_features, "-s 0 -t 2")
 
    test_features = []
    test_labels = []
    for inp in test_inputs:
        test_features.append(inp.features)
        test_labels.append(SolverLabels[inp.best_solver])
    
    predictions,[acc,mse,cor], oth = svm_predict(test_labels,test_features,model)


    all = 0
    cor = 0
    j=0
    pdb.set_trace()
    for i in range(len(test_inputs)):
        all += 1
        if LabelsSolver[predictions[i]] == test_inputs[i].best_solver:
            cor += 1
    pdb.set_trace()
    print("computed acc = ", cor/all)



    solv = ['z3','mathsat','cvc4','colibri']
    data = [ [], [], [], [], [], [], []]
    for i in range(len(test_inputs)):
        data[0].append(test_inputs[i].times['z3'])
        data[1].append(test_inputs[i].times['mathsat'])
        data[2].append(test_inputs[i].times['cvc4'])
        data[3].append(test_inputs[i].times['colibri'])
        data[4].append(test_inputs[i].times[LabelsSolver[predictions[i]]])
        data[5].append(test_inputs[i].times[random.choice(solv)])
        data[6].append(test_inputs[i].times[test_inputs[i].best_solver])

    

    for i in range(len(data)):
        data[i].sort()
        while data[i][-1] == 60:
            data[i].pop()

    plt.plot(data[0],label='z3')
    plt.plot(data[1],label='mathsat')
    plt.plot(data[2],label='cvc4')
    plt.plot(data[3],label='colibri')
    plt.plot(data[4],label='svm')
    plt.plot(data[5],label='rand')
    plt.plot(data[6],label='optimal')
    plt.legend()
    plt.show()


dir = sys.argv[1]
parse_data(glob.glob(dir+"*"))