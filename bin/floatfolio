#!/usr/bin/env python3
from src.input import Input
import random
import json
import csv
import glob
import sys
import src.settings as settings
import pdb
import pylab as plt
import src.input
from src.portfolio.rand import Rand
from src.portfolio.oracle import Oracle
from src.portfolio.linear_regression import Linear_Regression
from src.portfolio.ridge_regression import Ridge_Regression
from src.portfolio.svm_regression import SVM_Regression
from src.portfolio.knn_regression import KNN_Regression
from src.portfolio.log_regression import Logistic_Regression
import random



def scale_input_features(inputs):
	means = []
	dev =   []
	for i in range(len(inputs[0].features)):
		means.append(0.0)
		dev.append(0.0)
	for i in range(len(inputs)):
		for j in range(len(inputs[0].features)):
			means[j] += inputs[i].features[j]
	for i in range(len(means)):
		means[i] /= len(inputs)

	for i in range(len(inputs)):
		for j in range(len(inputs[0].features)):
			dev[j] += (inputs[i].features[j] - means[j]) * (inputs[i].features[j] - means[j])
	for i in range(len(means)):
		dev[i] = (dev[i]/len(inputs)) ** 0.5

	for i in range(len(inputs)):
		for j in range(len(inputs[0].features)):
			if dev[j] != 0.0:
				inputs[i].features[j] = (inputs[i].features[j] - means[j]) / dev[j]
			else:
				inputs[i].features[j] = 0.0

data_sets = ['bfuzz0']
inputs = []
for data_set in data_sets:
		with open('benchmarks/benchmark_data/' + data_set + '.csv') as csvfile:
					reader = csv.reader(csvfile)
					header = None
					for row in reader:
								if header == None:
										header = row
										continue
								time_dict = {}
								for i in range(1,len(row)):
									try:
										time_dict[header[i]]=float(row[i])
									except ValueError:
										if row[i] == 'err' or row[i] == 'N/A' or row[i] == 'timeout':
											time_dict[header[i]]=float(3.0 * settings.timeout)
										else:
											print(row[i])
											sys.exit(0)
								inputs.append(Input(row[0],time_dict))

random.shuffle(inputs)
print(len(inputs))
scale_input_features(inputs)
split = 0.85
train_inputs = inputs[:round(split * len(inputs)) ]
test_inputs  = inputs[round(split*len(inputs))+1:]



plot_data = []
solvers = list(test_inputs[0].times.keys())
for solver in solvers:
		plot_data.append([[],solver])
		for i in range(len(test_inputs)):
					plot_data[-1][0].append(test_inputs[i].times[solver])


#algorithms = [Rand,Oracle,Linear_Regression,SVM_Regression, SVM_Classify, Doc2Vec]
algorithms = [Rand,Oracle,Linear_Regression,Ridge_Regression,SVM_Regression,KNN_Regression,Logistic_Regression]
for alg in algorithms:
		classifier = alg()
		classifier.train(train_inputs)
		predictions = classifier.predict(test_inputs)
		plot_data.append([[],classifier.__name__()])
		for i in range(len(test_inputs)):
					plot_data[-1][0].append(test_inputs[i].times[predictions[i]])


for i in range(len(plot_data)):
		plot_data[i][0].sort()
		while plot_data[i][0][-1] >= settings.timeout:
					plot_data[i][0].pop()
for i in range(len(plot_data)):
		plt.plot(plot_data[i][0],label=plot_data[i][1])

plt.legend()
plt.show()