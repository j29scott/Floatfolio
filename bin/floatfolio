#!/usr/bin/env python3
from src.input import Input
import random
import json
import csv
import glob
import sys
import src.settings as settings
import pdb
import pylab as plt
import src.input
from src.portfolio.rand import Rand
from src.portfolio.oracle import Oracle
from src.portfolio.linear_regression import Linear_Regression
from src.portfolio.ridge_regression import Ridge_Regression
from src.portfolio.svm_regression import SVM_Regression
from src.portfolio.knn_regression import KNN_Regression
from src.portfolio.log_regression import Logistic_Regression
from src.portfolio.svm_classify import SVM_Classify
from src.portfolio.perceptron import Perceptron_Classify
from src.portfolio.log_regression import Logistic_Regression
from src.portfolio.sgd import SGD
import random



def scale_input_features(inputs):
	means = []
	dev =   []
	for i in range(len(inputs[0].features)):
		means.append(0.0)
		dev.append(0.0)
	for i in range(len(inputs)):
		for j in range(len(inputs[0].features)):
			means[j] += inputs[i].features[j]
	for i in range(len(means)):
		means[i] /= len(inputs)

	for i in range(len(inputs)):
		for j in range(len(inputs[0].features)):
			dev[j] += (inputs[i].features[j] - means[j]) * (inputs[i].features[j] - means[j])
	for i in range(len(means)):
		dev[i] = (dev[i]/len(inputs)) ** 0.5

	for i in range(len(inputs)):
		for j in range(len(inputs[0].features)):
			if dev[j] != 0.0:
				inputs[i].features[j] = (inputs[i].features[j] - means[j]) / dev[j]
			else:
				inputs[i].features[j] = 0.0

data_sets = ['smtlib','bfuzz0']
inputs = {}
for data_set in data_sets:
		inputs[data_set] = []
		with open('benchmarks/benchmark_data/' + data_set + '.csv') as csvfile:
					reader = csv.reader(csvfile)
					header = None
					for row in reader:
								if header == None:
										header = row
										continue
								time_dict = {}
								for i in range(1,len(row)):
									try:
										time_dict[header[i]]=float(row[i])
									except ValueError:
										if row[i] == 'err' or row[i] == 'N/A' or row[i] == 'timeout':
											time_dict[header[i]]=float(3.0 * settings.timeout)
										else:
											print(row[i])
											sys.exit(0)
								inputs[data_set].append(Input(row[0],time_dict))
		random.shuffle(inputs[data_set])
		scale_input_features(inputs[data_set])

train_data_set = ['bfuzz0']
test_data_set  = ['smtlib']
split = 0.8
train_inputs = []
test_inputs = []
for data_set in train_data_set:
	if data_set in test_data_set:
		train_inputs.extend(inputs[data_set][:round(split * len(inputs[data_set])) ])
	else:
		train_inputs.extend(inputs[data_set])
for data_set in test_data_set:
	if data_set in train_data_set:
		test_inputs.extend(inputs[data_set][round(split*len(inputs[data_set]))+1:])
	else:
		test_inputs.extend(inputs[data_set])

# train_inputs = inputs[:round(split * len(inputs)) ]
# test_inputs  = inputs[round(split*len(inputs))+1:]



plot_data = []
solvers = list(test_inputs[0].times.keys())
for solver in solvers:
		plot_data.append([[],solver,','])
		for i in range(len(test_inputs)):
					plot_data[-1][0].append(test_inputs[i].times[solver])


benchmarks = [Rand,Oracle]
regressors = [Linear_Regression,Ridge_Regression,SVM_Regression,KNN_Regression]
classifiers = [Logistic_Regression,SVM_Classify,Perceptron_Classify,SGD]

for alg in benchmarks + regressors + classifiers:
		model = alg()
		model.train(train_inputs)
		predictions,conf_mat = model.predict(test_inputs)
		if alg in benchmarks:
			plot_data.append([[],model.__name__(),'|'])
		elif alg in regressors:
			plot_data.append([[],model.__name__(),'x'])
		elif alg in classifiers:
			plot_data.append([[],model.__name__(),'*'])
		for i in range(len(test_inputs)):
			plot_data[-1][0].append(test_inputs[i].times[predictions[i]])
		print("Conf mat for " + model.__name__() + "\n")
		print(conf_mat)
		print("\n\n")


for i in range(len(plot_data)):
		plot_data[i][0].sort()
		while plot_data[i][0][-1] >= settings.timeout:
					plot_data[i][0].pop()
for i in range(len(plot_data)):
		plt.plot(plot_data[i][0],label=plot_data[i][1],marker=plot_data[i][2],markevery=20)

plt.legend()
plt.show()